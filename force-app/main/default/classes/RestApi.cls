/* Auto generated by CodeGen, edited by Brite*/
public class RestApi {
    private final String CALLOUT_NAME;
    private static final String HEADER_CONTENT_TYPE = 'Content-Type';
    private static final String HEADER_ACCEPT = 'Accept';
    private static final String HEADER_ACCEPT_DELIMITER = ',';
    
    private static final String PREFERRED_CONTENT_TYPE = 'application/json';
    private static final String PREFERRED_ACCEPT = 'application/json';
    
	    
    private boolean suppressNullInBody = true;
    
    private RestApi(){
        
    }
    
    public RestApi(String namedCredential){
        this.CALLOUT_NAME = namedCredential;
        this.suppressNullInBody = true;
    }
    
    public RestApi(String namedCredential, Boolean suppressNullInBody){
        this.CALLOUT_NAME = namedCredential;
        this.suppressNullInBody = suppressNullInBody;
    }
    
    public class Param {
        private String name, value;
        
        public Param(String name, String value) {
            this.name = name;
            this.value = value;
        }
        
        public override String toString() {
            return EncodingUtil.urlEncode(name, 'UTF-8') + '='
                + EncodingUtil.urlEncode(value, 'UTF-8');
        }
    }
    
    
    public static List<Param> getParamsFromMap(Map<String, object> mappedProperties){
        List<Param> paramList = new List<Param>();
        for (String name : mappedProperties.keySet()){
            if (mappedProperties.get(name) != null){
                Param p = new Param(name, String.valueOf(mappedProperties.get(name)));
                paramList.add(p);
            }
        }
        return paramList;
    }
    
    public  Map<String, String> getHeaders(HttpResponse res) {
        Map<String, String> headers = new Map<String, String>();
        List<String> headerKeys = res.getHeaderKeys();
        for (String headerKey : headerKeys) {
            headers.put(headerKey, res.getHeader(headerKey));
        }
        return headers;
    }
    
    public class ApiException extends Exception {
        private final Integer code;
        private final String status;
        private final Map<String, String> headers;
        private final String body;
        
        public ApiException(Integer code, String status, Map<String, String> headers, String body) {
            this('API returned HTTP ' + code + ': ' + status);
            this.code = code;
            this.status = status;
            this.headers = headers;
            this.body = body;
        }
        
        public Integer getStatusCode() {
            return code;
        }
        
        public String getStatus() {
            return status;
        }
        
        public Map<String, String> getHeaders() {
            return headers;
        }
        
        public String getBody() {
            return body;
        }
        
    }
    
    public Object invoke(
        String method, String path, Object body, List<Param> query, Map<String, Object> pathParams, Map<String, Object> headers, List<String> accepts,
        List<String> contentTypes, List<String> authMethods, Type returnType) {
            return invoke(method, path, body, query, pathParams, headers, accepts,
        contentTypes, authMethods, returnType, 10000);
        }
    
    public Object invoke(
        String method, String path, Object body, List<Param> query, Map<String, Object> pathParams, Map<String, Object> headers, List<String> accepts,
        List<String> contentTypes, List<String> authMethods, Type returnType, Integer timeout) {
            HttpResponse res = getResponse(method, path, body, query, pathParams, headers,
                                           accepts, contentTypes, authMethods, timeout);
            Integer code = res.getStatusCode();
            Boolean isFailure = code / 100 != 2;
            if (isFailure) {
                throw new ApiException(code, res.getStatus(), getHeaders(res), res.getBody());
            } else if (returnType != null) {
                return toReturnValue(res.getBody(), returnType, res.getHeader('Content-Type'));
            }
            return null;
        }
    private HttpResponse getResponse(
        String method, String path, Object body, List<Param> query,
        Map<String, Object> pathParams, Map<String, Object> headers, List<String> accepts,
        List<String> contentTypes, List<String> authMethods, Integer timeout) {
            
            HttpRequest req = new HttpRequest();
            req.setMethod(method);
            req.setEndpoint(toEndpoint(path, pathParams, query));
            req.setTimeout(timeout);
            
            String contentType = setContentTypeHeader(contentTypes, headers);
            setAcceptHeader(accepts, headers);
            setHeaders(req, headers);
            
            if (method != 'GET') {
                req.setBody(toBody(contentType, body));
            }
            Http htp = new Http();
            HttpResponse response = htp.send(req);
            
            return response;
        }
    
    private static Object toReturnValue(String body, Type returnType, String contentType) {
        if (contentType.contains('application/json') || contentType.contains('application/*+json')) {
            if (RestApiGenericResponse.class.isAssignableFrom(returnType)){
                
                RestApiGenericResponse responseInstance = (RestApiGenericResponse) returnType.newInstance();
                responseInstance.parseJson(body);
                return responseInstance;
            }
            else {
                Object o = JSON.deserialize(body, returnType);
                return o;
            }
        }
        return body;
    }
    
    private String toEndpoint(String path, Map<String, Object> params, List<Param> queryParams) {
        String query = '';
        if (queryParams != null) {
            for (Param p : queryParams){
                if (p.value != null) {
                    query+= '&' + p.name + '=' + String.valueOf(p.value);
                }
                
            }
            query = query.removeStart('&');
            query = '?' + query;
        }
        return 'callout:' + CALLOUT_NAME + toPath(path, params) + query.removeEnd('?');
    }
    
    private  String toPath(String path, Map<String, Object> params) {
        String formatted = path;
        for (String key : params.keySet()) {
            formatted = formatted.replace('{' + key + '}', String.valueOf(params.get(key)));
        }
        return formatted;
    }
    
    private String setContentTypeHeader(List<String> contentTypes, Map<String, Object> headers) {
        if (contentTypes.isEmpty()) {
            headers.put(HEADER_CONTENT_TYPE, PREFERRED_CONTENT_TYPE);
            return PREFERRED_CONTENT_TYPE;
        }
        for (String contentType : contentTypes) {
            if (PREFERRED_CONTENT_TYPE == contentType) {
                headers.put(HEADER_CONTENT_TYPE, contentType);
                return contentType;
            }
        }
        String contentType = contentTypes.get(0);
        headers.put(HEADER_CONTENT_TYPE, contentType);
        return contentType;
    }
    
    private static void setAcceptHeader(List<String> accepts, Map<String, Object> headers) {
        for (String accept : accepts) {
            if (PREFERRED_ACCEPT == accept) {
                headers.put(HEADER_ACCEPT, accept);
                return;
            }
        }
        if (!accepts.isEmpty()) {
            headers.put(HEADER_ACCEPT, String.join(accepts, HEADER_ACCEPT_DELIMITER));
        }
    }
    
    private void setHeaders(HttpRequest req, Map<String, Object> headers) {
        for (String headerName : headers.keySet()) {
            req.setHeader(headerName, String.valueOf(headers.get(headerName)));
        }
    }
    
    @TestVisible
    private virtual String toBody(String contentType, Object body) {
        if (contentType.contains('application/json')) {
            System.debug('Sending: ');
            System.debug(Json.serializePretty(body, this.suppressNullInBody));
            return Json.serialize(body, this.suppressNullInBody);            
        }
        return String.valueOf(body);
    }
}